---
title: "Analiza działania algorytmów minimalizacji stochastycznej"
author:
- Patryk Klatka
- Szymon Twardosz
output: html_notebook
editor_options:
markdown:
wrap: sentence
---

```{r, setup, echo=FALSE, message=FALSE, warning=FALSE}
# PDF Render: output: pdf_document

# NOTE: Use code below if you can't load data files
# setwd("/path/to/project/directory")

# Include libraries
library(smoof)
library(GA)
library(ggplot2)
library(hrbrthemes)
```

## Wstęp

Projekt ma na celu analizę działania algorytmów minimalizacji stochastycznej dwóch algorytmów: PRS (Pure Random Search) oraz GA (Genetic Algorithm).
Oba algorytmy były testowane na dwóch funkcjach z pakietu `smoof` z wymiarami: 2,10,20.
Każdy algorytm został uruchomiony 50 razy, a każde uruchomienie miało 1000 wywołań.
Każda funkcja była testowana na dwóch algorytmach, a wyniki zostały porównane pod kątem średnich znalezionych minimów, położenia rozkładu wyników oraz istotności statystycznej różnicy między średnim wynikiem obu algorytmów.
Analizy statystyczne zostały wykonane na poziomie istotności 0,05.

## Testowane funkcje

W celu przetestowania algorytmów zostały wybrane dwie funkcje z pakietu `smoof`: funkcja [Rosenbrocka](https://jakobbossek.github.io/smoof/reference/makeRosenbrockFunction.html) oraz [Rastrigina](https://jakobbossek.github.io/smoof/reference/makeRastriginFunction.html).
Każda funkcja została wygenerowana na trzech różnych wymiarach: 2, 10, 20.
Dziedziny funkcji, zgodnie z dokumentacją, wynoszą:

-   Funkcja Rosenbrocka: $x_i \in [−30,30]$ dla $i = 1, 2, \dots, n$
-   Funkcja Rastrigina: $x_i \in [−5.12,5.12]$ dla $i = 1, 2, \dots, n$

gdzie $n$ oznacza wymiar funkcji.

```{r}
# Rosenbrock function
rosenbrock_2D <- makeRosenbrockFunction(dimensions = 2L)
rosenbrock_10D <- makeRosenbrockFunction(dimensions = 10L)
rosenbrock_20D <- makeRosenbrockFunction(dimensions = 20L)

# Rastrigin function
rastrigin_2D <- makeRastriginFunction(dimensions = 2L)
rastrigin_10D <- makeRastriginFunction(dimensions = 10L)
rastrigin_20D <- makeRastriginFunction(dimensions = 20L)
```

## Stałe i funkcje pomocnicze

W celu ułatwienia analizy oraz łatwej zmiany parametrów, w tej sekcji zostały zdefiniowane stałe oraz funkcje pomocnicze.

```{r}
# Define number of calculations for each algorithm
number_of_calculations <- 50L

loadData <- function(filename) {
      #' Loads data from file
      #'
      #' @param filename Name of the file
      #' @return Returns data from file, otherwise NULL if file does not exist

  if (file.exists(filename)) {
    return(readRDS(filename))
  }else {
    return(NULL)
  }
}

saveData <- function(data, filename) {
      #' Saves data to file
      #'
      #' @param data Data to save
      #' @param filename Name of the file
      #' @return Returns data parameter

  saveRDS(data, filename)
  return(data)
}
```

## Algorytm PRS (Pure Random Search)

Opis algorytmu.

### Implementacja

```{r}
prs_algorithm <- function(f, cost = 1000L) {
      #' Pure Random Search algorithm
      #'
      #' @param f Function to minimize (from spoof package)
      #' @param cost Number of calculations
      #' @return Returns function value

  if (!isSmoofFunction(f)) {
    stop("Function is not from smoof package.")
  }

  # Generate points
  domain_min <- getLowerBoxConstraints(f)
  domain_max <- getUpperBoxConstraints(f)

  points <- matrix(0, nrow = cost, ncol = length(domain_min))
  for (i in seq_along(domain_min)) {
    uniform_distribution_points <- runif(cost, domain_min[i], domain_max[i])
    for (j in seq_along(uniform_distribution_points)) {
      points[j, i] <- uniform_distribution_points[j]
    }
  }

  # Return minimum function value
  return(min(apply(points, 1, f)))
}
```

### Generacja danych oraz obliczenie średnich wyników algorytmu

Generowanie minimalnych wartości funkcji za pomocą algorytmu PRS, obliczenie średniej z wyników oraz zapisanie ich do pliku rds.

```{r}
prs_rosenbrock_2D <- loadData("./data/prs_rosenbrock_2D.rds")
if (is.null(prs_rosenbrock_2D)) prs_rosenbrock_2D <- saveData(replicate(number_of_calculations, prs_algorithm(rosenbrock_2D)), "./data/prs_rosenbrock_2D.rds")
mean_prs_rosenbrock_2D <- mean(prs_rosenbrock_2D)

prs_rosenbrock_10D <- loadData("./data/prs_rosenbrock_10D.rds")
if (is.null(prs_rosenbrock_10D)) prs_rosenbrock_10D <- saveData(replicate(number_of_calculations, prs_algorithm(rosenbrock_10D)), "./data/prs_rosenbrock_10D.rds")
mean_prs_rosenbrock_10D <- mean(prs_rosenbrock_10D)

prs_rosenbrock_20D <- loadData("./data/prs_rosenbrock_20D.rds")
if (is.null(prs_rosenbrock_20D)) prs_rosenbrock_20D <- saveData(replicate(number_of_calculations, prs_algorithm(rosenbrock_20D)), "./data/prs_rosenbrock_20D.rds")
mean_prs_rosenbrock_20D <- mean(prs_rosenbrock_20D)

prs_rastrigin_2D <- loadData("./data/prs_rastrigin_2D.rds")
if (is.null(prs_rastrigin_2D)) prs_rastrigin_2D <- saveData(replicate(number_of_calculations, prs_algorithm(rastrigin_2D)), "./data/prs_rastrigin_2D.rds")
mean_prs_rastrigin_2D <- mean(prs_rastrigin_2D)

prs_rastrigin_10D <- loadData("./data/prs_rastrigin_10D.rds")
if (is.null(prs_rastrigin_10D)) prs_rastrigin_10D <- saveData(replicate(number_of_calculations, prs_algorithm(rastrigin_10D)), "./data/prs_rastrigin_10D.rds")
mean_prs_rastrigin_10D <- mean(prs_rastrigin_10D)

prs_rastrigin_20D <- loadData("./data/prs_rastrigin_20D.rds")
if (is.null(prs_rastrigin_20D)) prs_rastrigin_20D <- saveData(replicate(number_of_calculations, prs_algorithm(rastrigin_20D)), "./data/prs_rastrigin_20D.rds")
mean_prs_rastrigin_20D <- mean(prs_rastrigin_20D)
```

## Algorytm GA (Genetic Algorithm)

Algorytm genetyczny jest algorytmem ewolucyjnym, który bazuje na zasadzie ewolucji naturalnej.
Została wybrana implementacja z biblioteki `GA`, dostępnej w `CRAN`.
Przy korzystaniu z funkcji z tej biblioteki należy funkcję, która ma być minimalizowana, przekształcić do postaci `f(x) = -f(x)`, ponieważ domyślnie algorytm szuka maksimum.

### Implementacja

```{r}
ga_algorithm <- function(f, cost = 1000L) {
    #' Genetic Algorithm
    #'
    #' @param f Function to minimize (from spoof package)
    #' @param cost Number of calculations
    #' @return Returns function value

  if (!isSmoofFunction(f)) {
    stop("Function is not from smoof package.")
  }

  result <- ga(type = "real-valued",
               fitness = function(x) -f(x),
               lower = getLowerBoxConstraints(f),
               upper = getUpperBoxConstraints(f),
               maxiter = cost,
               run = cost)

  return(f(result@solution))
}

```

### Generacja danych oraz obliczenie średnich wyników algorytmu

Generowanie minimalnych wartości funkcji za pomocą algorytmu GA, obliczenie średniej z wyników oraz zapisanie ich do pliku rds.

```{r}
ga_rosenbrock_2D <- loadData("./data/ga_rosenbrock_2D.rds")
if (is.null(ga_rosenbrock_2D))ga_rosenbrock_2D <- saveData(replicate(number_of_calculations, ga_algorithm(rosenbrock_2D)), "./data/ga_rosenbrock_2D.rds")
mean_ga_rosenbrock_2D <- mean(ga_rosenbrock_2D)

ga_rosenbrock_10D <- loadData("./data/ga_rosenbrock_10D.rds")
if (is.null(ga_rosenbrock_10D)) ga_rosenbrock_10D <- saveData(replicate(number_of_calculations, ga_algorithm(rosenbrock_10D)), "./data/ga_rosenbrock_10D.rds")
mean_ga_rosenbrock_10D <- mean(ga_rosenbrock_10D)

ga_rosenbrock_20D <- loadData("./data/ga_rosenbrock_20D.rds")
if (is.null(ga_rosenbrock_20D)) ga_rosenbrock_20D <- saveData(replicate(number_of_calculations, ga_algorithm(rosenbrock_20D)), "./data/ga_rosenbrock_20D.rds")
mean_ga_rosenbrock_20D <- mean(ga_rosenbrock_20D)

ga_rastrigin_2D <- loadData("./data/ga_rastrigin_2D.rds")
if (is.null(ga_rastrigin_2D)) ga_rastrigin_2D <- saveData(replicate(number_of_calculations, ga_algorithm(rastrigin_2D)), "./data/ga_rastrigin_2D.rds")
mean_ga_rastrigin_2D <- mean(ga_rastrigin_2D)

ga_rastrigin_10D <- loadData("./data/ga_rastrigin_10D.rds")
if (is.null(ga_rastrigin_10D)) ga_rastrigin_10D <- saveData(replicate(number_of_calculations, ga_algorithm(rastrigin_10D)), "./data/ga_rastrigin_10D.rds")
mean_ga_rastrigin_10D <- mean(ga_rastrigin_10D)

ga_rastrigin_20D <- loadData("./data/ga_rastrigin_20D.rds")
if (is.null(ga_rastrigin_20D)) ga_rastrigin_20D <- saveData(replicate(number_of_calculations, ga_algorithm(rastrigin_20D)), "./data/ga_rastrigin_20D.rds")
mean_ga_rastrigin_20D <- mean(ga_rastrigin_20D)
```

## Porównanie średnich wyników algorytmów oraz ich analiza pod kątem położenia i rozproszenia rozkładu

```{r}
draw_plots <- function(prs, ga) {
  #PRS Algorithm
  hist(prs, col = "yellow", xlab = "Return value of PRS Algorithm")
  boxplot(prs, col = 'yellow', ylab = "Return value of PRS Algorithm", main = "Boxplot of PRS Algorithm")

  #GA Algorithm
  hist(ga, col = "green", xlab = "Return value of GA Algorithm")
  boxplot(ga, col = 'green', ylab = "Return value of GA Algorithm", main = "Boxplot of GA Algorithm")

  #Comparison
  data <- data.frame(prs, ga)

  func <- c(rep("PRS", length(prs)), rep("GA", length(ga)))
  value <- c(prs, ga)
  data <- data.frame(func, value)
  boxplot(data$value ~ data$func, col = terrain.colors(4))
}
```

### Funkcja Rosenbrocka

#### Wymiar 2D

```{r}
draw_plots(prs_rosenbrock_2D, ga_rosenbrock_2D)
```

#### Wymiar 10D

```{r}
draw_plots(prs_rosenbrock_10D, ga_rosenbrock_10D)
```

#### Wymiar 20D

```{r}
draw_plots(prs_rosenbrock_20D, ga_rosenbrock_20D)
```

### Funkcja Rastrigina

#### Wymiar 2D

```{r}
draw_plots(prs_rastrigin_2D, ga_rastrigin_2D)
```

#### Wymiar 10D

```{r}
draw_plots(prs_rastrigin_10D, ga_rastrigin_10D)
```

#### Wymiar 20D

```{r}
draw_plots(prs_rastrigin_20D, ga_rastrigin_20D)
```

## Analiza istotności statystycznej różnicy między wynikami algorytmów

W tej sekcji została przeprowadzona analiza istotności statystycznej różnicy między wynikami algorytmów.
W tym celu wykorzystano przedziały ufności 95% oraz test dla wartości średniej.
Ze względu na tą samą oczekiwaną wartość minimum funkcji Rosenbrocka oraz Rastrigina [równą 0](https://en.wikipedia.org/wiki/Test_functions_for_optimization#Test_functions_for_single-objective_optimization),
test hipotezy zerowej przyjmuje postać: $H_0: m = 0$, gdzie $m$ to wartość przeciętna algorytmu.
Ze względu na liczbę powtórzeń założono, że rozkład średniej może być sensownie przybliżony przez rozkład normalny $N(m,\sigma)$.
Ponieważ nie znamy parametru $\sigma$, do wyznaczenia przedziałów ufności wykorzystano statystykę:

\begin{equation}
T=\frac{\overline{X}-m}{\frac{s}{\sqrt{n}}}
\end{equation}

Można pokazać, że

\begin{equation}
T \sim t_{n-1}
\end{equation}

gdzie $t_{n-1}$ to rozkład t o $n$ stopniach swobody, zwanym też rozkładem Studenta.

W tym przypadku przedział ufności dla średniej wynosi:

\begin{equation}
[ \overline{X} - t_{n-1} \frac{s}{\sqrt{n}}, \overline{X} + t_{n-1} \frac{s}{\sqrt{n}} ]
\end{equation}

Analogicznie dla testu wartości średniej, ponieważ nie znamy parametru \sigma, wykorzystamy test Studenta, korzystając ze statystyki $T$.
Zbiór krytyczny na poziomie istotności $\alpha$ dla dwustronnej hipotezy alternatywnej ma postać:

\begin{equation}
C = \{t: t \leq -t_{1-\frac{\alpha}{2},n-1} \lor t \geq t_{1-\frac{\alpha}{2},n-1}\}
\end{equation}

P-wartość wynosi:

\begin{equation}
p(t) = 2 \cdot P(T \geq |t| | H_0)
\end{equation}


### Funkcja Rosenbrocka

#### Wymiar 2D

```{r}
# Algorytm PRS
t.test(prs_rosenbrock_2D, mu = 0, conf.level = 0.95)
```
```{r}
# Algorytm GA
t.test(ga_rosenbrock_2D, mu = 0, conf.level = 0.95)
```


#### Wymiar 10D


```{r}
# Algorytm PRS
t.test(prs_rosenbrock_10D, mu = 0, conf.level = 0.95)
```
```{r}
# Algorytm GA
t.test(ga_rosenbrock_10D, mu = 0, conf.level = 0.95)
```

#### Wymiar 20D


```{r}
# Algorytm PRS
t.test(prs_rosenbrock_20D, mu = 0, conf.level = 0.95)
```
```{r}
# Algorytm GA
t.test(ga_rosenbrock_20D, mu = 0, conf.level = 0.95)
```

### Funkcja Rastrigina

#### Wymiar 2D


```{r}
# Algorytm PRS
t.test(prs_rastrigin_2D, mu = 0, conf.level = 0.95)
```
```{r}
# Algorytm GA
t.test(ga_rastrigin_2D, mu = 0, conf.level = 0.95)
```

#### Wymiar 10D

```{r}
# Algorytm PRS
t.test(prs_rastrigin_10D, mu = 0, conf.level = 0.95)
```
```{r}
# Algorytm GA
t.test(ga_rastrigin_10D, mu = 0, conf.level = 0.95)
```

#### Wymiar 20D


```{r}
# Algorytm PRS
t.test(prs_rastrigin_20D, mu = 0, conf.level = 0.95)
```
```{r}
# Algorytm GA
t.test(ga_rastrigin_20D, mu = 0, conf.level = 0.95)
```

#### Analiza wyników

Algorytm PRS (Pure Random Search) i algorytm genetyczny (GA) działają poprawnie na wygenerowanych zbiorach danych.
Obydwa algorytmy dąrzą do uzyskania minimalnej wartości optymalizowanej funckji.
Natomiast lepiej z tym zadaniem radzi sobie algorytm genetyczny.

Dla funckji 2D (przy budżecie 1000 wywołań) średnia osiągana wartość jest rzędu 10\^-8 (funkcja Rastrigina) lub 10\^-5 (funkcja Rosenbrocka).
Podczas gdy średnia drugiego algorytmu wynosi aż 1.7 (funkcja Rastrigina) oraz 0.6 (funkcja Rosenbrocka).

Dla większej ilości wymiarów (tj. 10,20) nadal obserwujemy przewagę algorytmu GA nad PRS.
Tutaj również algorytmy uzyskały lepsze wyniki dla funkcji Rastrigina ( różniły się one o rząd/rzędy wielkości) niz dla funkcji Rosenbrocka.

Szczegółowe informację dotyczące średnich dla poszczególnych wywołań funkcji oraz minimalnej uzyskanej wartości znajdują się poniżej.

##### Algorytm (GA) - średnie wyniki

| Wymiar | Rastrigin    | Rosenbrock   |
|--------|--------------|--------------|
| 2      | 8.741563e-08 | 2.026331e-05 |
| 10     | 0.002755626  | 5.952174     |
| 20     | 0.324142     | 39.86294     |

##### Algorytm (PRS) - średnie wynki

| Wymiar | Rastrigin | Rosenbrock |
|--------|-----------|------------|
| 2      | 1.701016  | 0.6033034  |
| 10     | 86.10899  | 28555.61   |
| 20     | 226.0245  | 305825.3   |
